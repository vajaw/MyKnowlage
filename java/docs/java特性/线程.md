# Java 线程
Java线程是 Java 程序实现并发和多任务的重要基础。通过线程，程序可以在同一时间执行多个任务，从而提高效率和响应能力。


## **1. 什么是线程？**
线程是进程中的一个执行单元，允许程序同时执行多个任务。一个 Java 程序启动时，至少会有一个主线程（`main` 方法运行的线程）。通过创建新的线程，可以在程序中实现并发。

### **线程与进程的区别**
- **进程**：操作系统分配资源的单位，每个 Java 应用程序运行时都是一个进程。
- **线程**：进程中的一个执行路径，同一个进程可以有多个线程共享资源（如内存）。


## **2. 创建线程的方式**
Java 中有两种主要方式创建线程：
1. **继承 `Thread` 类**
2. **实现 `Runnable` 接口**
3. **实现 `Callable` 接口**

### **(1) 继承 `Thread` 类**
通过继承 `Thread` 类并重写 `run()` 方法，可以定义一个线程。

#### **示例代码**
```java
// 定义一个线程类
class MyThread extends Thread {
    @Override
    public void run() {
        // 线程要执行的任务
        for (int i = 0; i < 5; i++) {
            System.out.println("线程 MyThread 正在运行：" + i);
        }
    }
}

public class ThreadExample {
    public static void main(String[] args) {
        // 创建线程对象
        MyThread thread = new MyThread();
        // 启动线程
        thread.start();
    }
}
```


### **(2) 实现 `Runnable` 接口**
实现 `Runnable` 接口比继承 `Thread` 类更灵活，因为 Java 不支持多继承，使用 `Runnable` 可以避免继承冲突。

#### **示例代码**
```java
// 创建一个实现 Runnable 的类
class MyRunnable implements Runnable {
    @Override
    public void run() {
        // 线程要执行的任务
        for (int i = 0; i < 5; i++) {
            System.out.println("线程 MyRunnable 正在运行：" + i);
        }
    }
}

public class ThreadExample {
    public static void main(String[] args) {
        // 创建 Runnable 对象
        MyRunnable runnable = new MyRunnable();
        // 创建线程对象，并传入 Runnable
        Thread thread = new Thread(runnable);
        // 启动线程
        thread.start();
    }
}
```

### **(3) 实现 `Callable` 接口**

- **`Callable` 和 `Runnable` 的区别**：
    1. **有返回值**：`Callable` 可以返回一个计算结果，而 `Runnable` 无法返回值。
    2. **抛出异常**：`Callable` 方法允许抛出受检异常（`Checked Exception`），而 `Runnable` 不支持。
    3. **方法名称不同**：`Runnable` 的核心方法是 `run()`，`Callable` 的核心方法是 `call()`。

- **定义**：
  `Callable` 是一个泛型接口，定义如下：
  ```java
  public interface Callable<V> {
      V call() throws Exception;
  }
  ```
    - `V`：表示返回值的类型。
    - `call()`：需要实现的方法，执行线程任务并返回结果。

使用 `Callable` 通常涉及以下步骤：
1. 创建一个实现 `Callable` 接口的类。
2. 将 `Callable` 任务提交到线程池（通过 `ExecutorService`）。
3. 使用 `Future` 对象获取任务的执行结果。
#### **示例代码**
```java
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class CallableExample {
    public static void main(String[] args) {
        // 创建一个 Callable 实现类
        Callable<Integer> task = () -> {
            System.out.println("子线程正在执行任务...");
            Thread.sleep(2000); // 模拟耗时操作
            return 123; // 返回结果
        };

        // 创建线程池
        ExecutorService executor = Executors.newSingleThreadExecutor();

        // 提交任务，返回 Future 对象
        Future<Integer> result = executor.submit(task);

        try {
            // 获取任务的返回值（阻塞，直到任务完成）
            Integer value = result.get();
            System.out.println("任务执行结果：" + value);
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        }

        // 关闭线程池
        executor.shutdown();
    }
}
```

### **(4). Callable 的核心类：Future 和 FutureTask**
#### **(1) Future**
- `Future` 是一个接口，表示一个异步任务的结果。
- **常用方法**：
    - `get()`：获取任务的结果，会阻塞直到任务完成。
    - `isDone()`：检查任务是否完成。
    - `cancel()`：取消任务。
    - `isCancelled()`：检查任务是否被取消。
#### **(2) FutureTask**
- `FutureTask` 是 `Future` 的一个实现类，既可以作为一个任务（实现了 `Runnable` 接口），也可以作为一个 `Future` 获取任务结果。
- **特点**：
    - 可以直接执行，也可以提交给线程池执行。
    - 适用于需要同时实现 `Runnable` 和 `Callable` 的场景。
- **源码实现**
  - private Object outcome 保留线程call返回的结果
  - 
  

#### **示例代码：使用 FutureTask**
```java
import java.util.concurrent.Callable;
import java.util.concurrent.FutureTask;

public class FutureTaskExample {
    public static void main(String[] args) {
        // 创建 Callable 任务
        Callable<Integer> task = () -> {
            System.out.println("子线程正在执行任务...");
            Thread.sleep(2000); // 模拟耗时操作
            return 42; // 返回结果
        };

        // 创建 FutureTask
        FutureTask<Integer> futureTask = new FutureTask<>(task);

        // 创建并启动线程
        Thread thread = new Thread(futureTask);
        thread.start();

        try {
            // 获取任务结果
            Integer result = futureTask.get();
            System.out.println("任务执行结果：" + result);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

### **(5) 使用 Lambda 表达式**
从 Java 8 开始，可以使用 Lambda 表达式简化 `Runnable` 的实现。

#### **示例代码**
```java
public class ThreadExample {
    public static void main(String[] args) {
        // 使用 Lambda 创建 Runnable
        Runnable runnable = () -> {
            for (int i = 0; i < 5; i++) {
                System.out.println("线程 Lambda 正在运行：" + i);
            }
        };

        // 创建线程并启动
        Thread thread = new Thread(runnable);
        thread.start();
    }
}
```


## **3. 线程的生命周期**
Java 线程的生命周期包括以下几个状态：
1. **新建状态**（New）：线程对象被创建，但还没有调用 `start()` 方法。
2. **就绪状态**（Runnable）：线程调用了 `start()` 方法，等待 CPU 调度。
3. **运行状态**（Running）：线程获得 CPU 时间片，开始执行 `run()` 方法。
4. **阻塞状态**（Blocked）：线程因等待资源或其他原因暂停执行。
5. **终止状态**（Terminated）：线程执行完毕或被强制结束。

### **线程状态的示例**
```java
Thread.State state = Thread.currentThread().getState();
System.out.println("当前线程状态：" + state);
```


## **4. 常见线程控制方法**
Java 提供了一些方法来控制线程的行为：

- **(1) `sleep()`**
让线程暂停一段时间。`Thread.sleep(milliseconds)` 会让当前线程休眠指定毫秒数。

- **(2) `join()`**
让一个线程等待另一个线程执行完毕。

- **(3) `yield()`**
让出当前线程的 CPU 时间片，使其他线程有机会运行。

- **(4) `interrupt()`**
中断线程。可以通过 `interrupt()` 方法通知线程停止执行。

测试代码详见 java/java24/src/main/java/org/example/multithreading/thread/method


## **5. 线程同步**
多个线程操作共享数据时可能会导致数据不一致问题，Java 提供了以下机制来解决线程安全问题：


- **(1) `synchronized`**
使用 `synchronized` 关键字可以实现线程同步。
- **(2) `Lock`**
`Lock` 是 `java.util.concurrent` 包中的一种更灵活的线程同步机制。

测试代码详见 java/java24/src/main/java/org/example/multithreading/thread/method/sync